<<생성자>>
생성자는 객체가 생성될 때 한 번 호출되는 특별한 메서드

[객체 생성]
클래스 타입 변수 = new 생성자();
-----------          --------
^                          ^
|____ 사용할 클래스의 타입  |______ 클래스 안에 미리 정의되어 있는 생성자 메소드를 호출
                                   특별한 메소드지만 일반메소드와 동일하게 메소드를 실행할 때 외부에서 데이터를
                                   입력받아 사용하는 것이 가능
                                   ------------------
                                   매개변수를 전달 받을 수 있다.

- 생성자는 일반 메소드와 다르게 객체가 생성될 때 한번만 호출되는 메소드
- new 연산자가 생성자 메소드를 보고 메모리에 할당해야 하는 클래스가 무엇인지 파악하고 작업해야 하므로 생성자 메소드의 규칙이 존재
- 생성자 메소드는 주로 어디에 써???? 여기서 뭐하는거야???
    => 객체가 생성될때 처리해야 하는 기능이나 처음 실행되어야 하는 로직을 정의할 목적으로 사용
    => db연결, 네트워크 접속, os랑 통신해서 읽거나 os의 자원을 사용하는 경우
    => 사용자 정의 객체의 생성자는 주로 객체가 갖고있는 속성의 값을 초기화 하는 용도

[생성자 규칙]
1. 객체가 생성될 때 무조건 생성자가 호출 되어야 한다. 
   개발자가 클래스를 정의하면서 생성자를 정의하지 않으면 컴파일러가 매개변수 없는 생성자를 만들어준다. (기본 생성자)

2. 생성자의 이름은 클래스명과 대소문자까지 동일하게 정의한다.
3. 생성자는 특별한 메소드이므로 리턴타입을 명시하지 않는다. (void도 안쓴다.)
4. 생성자도 메소드이므로 매개변수를 정의할 수 있다.
    => 사용자 정의로 작성하는 생성자에는 멤버변수를 초기화 할 수 있도록 코드를 작성하는 것이 일반적
    => 객체가 생성될 때 객체의 멤버변수를 모두 초기화
                            ---------------------
                              멤버변수에 값을 할당

5. 생성자도 오버로딩을 지원한다.
    => 생성자를 여러개 정의할 수 있다. 매개변수 개수, 타입, 순서를 다르게 작성

6. 클래스에 생성자를 정의하면 컴파일러는 더 이상 기본생성자를 제공하지 않는다.
7. 프레임워크 내부에서 사용되는 것은 기본 생성자이므로 기본생성자는 무조건 정의한다.
8. 생성자가 오버로딩 되어 있으므로 생성자 안에서 다른 생성자를 호출할 수 있다.
    [문법]
    this(매개변수1, 매개변수2...)
    ---------------------------
    호출하고 싶은 생성자의 매개변수 갯수와 타입에 맞게 정의해서 호출
    => 생성자의 호출문은 반드시 생성자의 첫 번째 문장에서 호출해야 한다.
